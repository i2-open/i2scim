/*
 * Copyright 2021.  Independent Identity Incorporated
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.independentid.scim.test.http;

import com.fasterxml.jackson.core.JsonGenerator;
import com.fasterxml.jackson.databind.JsonNode;
import com.independentid.scim.core.ConfigMgr;
import com.independentid.scim.core.err.ScimException;
import com.independentid.scim.protocol.ScimParams;
import com.independentid.scim.protocol.ScimResponse;
import com.independentid.scim.resource.ScimResource;
import com.independentid.scim.schema.SchemaManager;
import com.independentid.scim.serializer.JsonUtil;
import io.quarkus.test.junit.QuarkusTest;
import io.quarkus.test.junit.TestProfile;
import org.apache.http.Header;
import org.apache.http.HttpEntity;
import org.apache.http.HttpHeaders;
import org.apache.http.client.methods.CloseableHttpResponse;
import org.apache.http.client.methods.HttpPost;
import org.apache.http.entity.ContentType;
import org.apache.http.entity.StringEntity;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.HttpClients;
import org.apache.http.util.EntityUtils;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.MethodOrderer;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestMethodOrder;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.annotation.Resource;
import javax.inject.Inject;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.io.StringWriter;
import java.net.MalformedURLException;
import java.net.URL;
import java.nio.charset.StandardCharsets;
import java.nio.charset.UnsupportedCharsetException;
import java.text.ParseException;
import java.time.Duration;
import java.time.Instant;
import java.util.*;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.fail;

/**
 * LoadScimClusterTest can be used to test an i2scim K8S deployment.  This module loads previously
 * generated random test data into the server. It normally generates a number of unique id conflicts (e.g.
 * usernames) to show that the Mongo indexing is working.
 *
 * Note this test is EXCLUDED from maven tests (see parent pom.xml)
 *
 * Note: Data files generated by RandomUser.me library.
 */
@QuarkusTest
@TestProfile(ScimClientProfile.class)
@TestMethodOrder(MethodOrderer.MethodName.class)
public class LoadScimClusterTest {

    private final static Logger logger = LoggerFactory.getLogger(LoadScimClusterTest.class);

    static int testThreads = 5;

    //private static String userSchemaId = "urn:ietf:params:scim:schemas:core:2.0:User";

    @Inject
    @Resource(name="SchemaMgr")
    SchemaManager smgr;

    static URL baseUrl;

    String auth = "Basic " + Base64.getEncoder().encodeToString(("admin:admin").getBytes());

    //private final static String dataSet = "classpath:/data/user-10pretty.json";
    static String dataSet = "classpath:/data/user-5000.json";

    private  static ArrayList<ScimResource> data;
    private final static List<String> paths = Collections.synchronizedList(new ArrayList<>());

    static String req = null;

    private static String readTime = null;

    protected synchronized ScimResource getRecord() {
        if (data.isEmpty()) return null;
        return data.remove(0); // remove and return the first item in the array.
    }

    @Test
    public void a_initializeData() throws IOException {


        InputStream fis = ConfigMgr.findClassLoaderResource("/data/cluster-config.prop");
        if (fis == null)
            throw new FileNotFoundException("Could not locate cluster-config.prop");
        Properties prop = new Properties();
        prop.load(fis);
        fis.close();

        //String endpoint = System.console().readLine();
        baseUrl = new URL(prop.getProperty("cluster_url"));

        String cfgThreads = prop.getProperty("threads");
        if (cfgThreads != null)
            testThreads = Integer.parseInt(cfgThreads);

        String dataFile = prop.getProperty("dataset");
        if (data != null)
            dataSet = dataFile;

        logger.info("========== Scim Concurrent Test Sample Load ==========");
        logger.info("\tK8S Load endpoint:\t"+baseUrl.toString());
        logger.info("\tClient threads:\t"+testThreads);
        logger.info("\tTest data file:\t"+dataSet);
        logger.info("\tInitializing test data set");

        try {
            data = readSampleData(smgr,dataSet);
        } catch (IOException | ParseException | ScimException e) {
            fail("Unable to read in sample data: "+e.getLocalizedMessage(),e);
        }
    }

    public static class ProcessedCounter {
        private static int count= 0;
        public static synchronized void increment() {
            int temp = count;
            count = temp + 1;
        }

        public static int getCount() { return count; }
    }
    /**
     * This test checks that a JSON user can be parsed into a SCIM Resource
     */
    @Test
    public void b_parallelTest() throws MalformedURLException, InterruptedException {
        logger.info("\tLoading "+data.size()+" records");

        Instant start = Instant.now();

        URL rUrl = new URL(baseUrl,"/Users");
        req = rUrl.toString();

        int numberOfThreads = testThreads;
        ExecutorService service = Executors.newFixedThreadPool(numberOfThreads);
        CountDownLatch latch = new CountDownLatch(numberOfThreads);

        for (int i = 0; i < numberOfThreads; i++) {
            final int tcnt = i;

            service.execute(() -> {
                Instant tstart = Instant.now();

                int cnt = 0;
                CloseableHttpClient client = HttpClients.createDefault();
                ScimResource record = getRecord();
                while (record != null) {
                    sendUser(client,record);
                    cnt++;  // increment records processed
                    record = getRecord(); // grab the next if available
                }
                try {
                    client.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
                Instant tend = Instant.now();
                Duration threadTime = Duration.between(tstart, tend);
                String elapse = threadTime.getSeconds()+"."+threadTime.getNano()+"secs";
                logger.info("\t***Thread #"+ tcnt +" complete. Number of records processed: "+cnt+", elapsed: "+elapse);
                latch.countDown();
            });
        }
        latch.await();
        Instant end = Instant.now();
        Duration loadTime = Duration.between(start, end);
        String elapse = loadTime.getSeconds()+"."+loadTime.getNano()+"secs";
        logger.info("------Summary------");
        logger.info("Read time:\t"+readTime);
        logger.info("Create time:\t"+elapse);
        logger.info("Records read: "+data.size()+", processed: "+ ProcessedCounter.count+", created: "+paths.size());

        // There are a number of conflicts. Actual is 4978
        //assertThat(paths.size())
        //	.isEqualTo(data.size());
        assertThat(paths.size())
                .isEqualTo(4978);


    }


    public void sendUser(CloseableHttpClient client, ScimResource user) {

        try {

            StringEntity reqEntity = null;
            String record;
            try {
                record = user.toJsonString();
                //logger.debug(record);
                reqEntity = new StringEntity(record, ContentType.create(ScimParams.SCIM_MIME_TYPE, StandardCharsets.UTF_8));
            } catch (UnsupportedCharsetException e) {
                fail("Unexpected error serializing sample data: " + e.getLocalizedMessage(), e);
            }

            HttpPost post = new HttpPost(req);
            post.setEntity(reqEntity);
            post.setHeader(HttpHeaders.AUTHORIZATION, auth);
            CloseableHttpResponse resp = client.execute(post);

            if (resp.getStatusLine().getStatusCode() == ScimResponse.ST_BAD_REQUEST) {

                //logger.error("Request entity:\n" + record);
                HttpEntity bentity = resp.getEntity();
                String body = EntityUtils.toString(bentity);
                logger.warn("Error received:\n" + body);
                assertThat(body)
                        .as("Is a uniqueness error")
                        .contains(ScimResponse.ERR_TYPE_UNIQUENESS);

                return;
            } else {

                assertThat(resp.getStatusLine().getStatusCode())
                        .as("Create user response status of 201")
                        .isEqualTo(ScimResponse.ST_CREATED);

            }
            ProcessedCounter.increment();
            Header[] hloc = resp.getHeaders(HttpHeaders.LOCATION);
            paths.add(hloc[0].getValue());
            resp.close();

        } catch (IOException e) {
            Assertions.fail("Exception occured loading records: " + e.getMessage(), e);
        }
    }

    protected static ArrayList<ScimResource> readSampleData(SchemaManager smgr, String dataSet) throws IOException, ParseException, ScimException {
        ArrayList<ScimResource> data = new ArrayList<>();
        logger.debug("\t\tReading sample data from: "+dataSet);
        Instant start = Instant.now();

        InputStream dataStream = ConfigMgr.findClassLoaderResource(dataSet);
        JsonNode dataNode = JsonUtil.getJsonTree(dataStream);

        JsonNode info = dataNode.get("info");
        String seed = info.get("seed").asText();
        String vers = info.get("version").asText();
        logger.debug("\t\tSeed: "+seed+", Vers: "+vers);

        dataNode = dataNode.get("results");
        logger.debug("\t\tJSON Parsed "+dataNode.size()+" records.");
        Iterator<JsonNode> iter = dataNode.elements();
        int cnt=0;
        while (iter.hasNext()) {
            data.add(parseUser(smgr,iter.next()));
            cnt++;
        }
        Instant end = Instant.now();
        Duration dur = Duration.between(start, end);
        readTime = dur.getSeconds()+"."+dur.getNano()+"secs";
        logger.info("\t\tMapping complete. "+cnt+" records mapped to SCIM Resource in "+readTime);
        return data;
    }

    protected static ScimResource parseUser(SchemaManager smgr, JsonNode mapNode) throws IOException, ParseException, ScimException {
        StringWriter writer = new StringWriter();

        JsonGenerator gen = JsonUtil.getGenerator(writer, true);
        gen.writeStartObject();

        gen.writeArrayFieldStart("schemas");
        gen.writeString(ScimParams.SCHEMA_SCHEMA_User);
        gen.writeString(ScimParams.SCHEMA_SCHEMA_Ent_User);
        gen.writeEndArray();

        gen.writeObjectFieldStart("meta");
        gen.writeStringField("resourceType", "User");
        gen.writeEndObject();

        JsonNode name = mapNode.get("name");

        gen.writeFieldName("name");
        gen.writeStartObject();

        gen.writeStringField("honorificPrefix", name.get("title").asText());
        gen.writeStringField("familyName", name.get("last").asText());
        gen.writeStringField("givenName", name.get("first").asText());
        String formatted =  name.get("first").asText() + " " +  name.get("last").asText();
        gen.writeStringField("formatted", formatted);
        gen.writeEndObject();

        JsonNode locNode = mapNode.get("location");
        gen.writeFieldName("addresses");
        gen.writeStartArray();
        gen.writeStartObject();

        JsonNode snode = locNode.get("street");
        String street = snode.get("number").asText() + " " + snode.get("name").asText();
        gen.writeStringField("streetAddress", street);
        gen.writeStringField("locality", locNode.get("city").asText());
        gen.writeStringField("region", locNode.get("state").asText());
        gen.writeStringField("country", locNode.get("country").asText());
        gen.writeStringField("postalCode", locNode.get("postcode").asText());
        gen.writeStringField("type", "work");
        gen.writeBooleanField("primary", true);
        gen.writeEndObject();
        gen.writeEndArray();

        gen.writeFieldName("emails");
        gen.writeStartArray();
        gen.writeStartObject();
        gen.writeStringField("value", mapNode.get("email").asText());
        gen.writeStringField("type", "work");
        gen.writeEndObject();
        gen.writeEndArray();

        gen.writeStringField("userName", mapNode.path("login").get("username").asText());
        gen.writeStringField("password", mapNode.path("login").get("password").asText());
        gen.writeStringField("externalId", mapNode.path("login").get("uuid").asText());

        gen.writeFieldName("phoneNumbers");
        if (mapNode.get("phone") != null) {
            gen.writeStartArray();
            gen.writeStartObject();
            gen.writeStringField("value", mapNode.get("phone").asText());
            gen.writeStringField("type", "work");
            gen.writeEndObject();
        }
        if (mapNode.get("cell") != null) {
            gen.writeStartObject();
            gen.writeStringField("value", mapNode.get("cell").asText());
            gen.writeStringField("type", "mmobile");
            gen.writeEndObject();
        }
        gen.writeEndArray();

        JsonNode photos = mapNode.get("picture");
        if (photos != null) {
            gen.writeFieldName("photos");
            if (photos.get("large") != null) {
                gen.writeStartArray();
                gen.writeStartObject();
                gen.writeStringField("value", photos.get("large").asText());
                gen.writeStringField("type", "photo");
                gen.writeEndObject();
            }
            if (photos.get("thumbnail") != null) {
                gen.writeStartObject();
                gen.writeStringField("value", photos.get("thumbnail").asText());
                gen.writeStringField("type", "thumbnail");
                gen.writeEndObject();
            }
            gen.writeEndArray();
        }
        JsonNode tz = mapNode.path("location").get("timezone");
        String offset = "GMT"+tz.get("offset").asText();
        String[] names = TimeZone.getAvailableIDs(tz.get("offset").asInt());
        logger.debug("Zone names: "+ Arrays.toString(names));
        TimeZone zone = TimeZone.getTimeZone(offset);
        gen.writeStringField("timezone", zone.getID());

        gen.close();
        writer.close();

        JsonNode scimjnode = JsonUtil.getJsonTree(writer.toString());
        return new ScimResource(smgr,scimjnode,null,"Users");

    }
}
